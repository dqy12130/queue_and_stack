

#include<iostream>
#include<stdlib.h>
using namespace std;
#define STACK_SIZE 100
#define ERROR 0;
#define OK 1;
typedef int SElemType;
typedef int Status;

typedef struct stack//顺序栈
{
	SElemType *base;
	SElemType *top;
	int stacksize;
}SqStack,*SqStackList;
Status InitStack(SqStack &);//构建一个空栈
Status DestroyStack(SqStack&);//销毁栈
Status ClearStack(SqStack&);//清空栈
void StackEmpty(SqStack);//判栈空
int  Stacklength(SqStack);//求栈的长度
SElemType Gettop(SqStack);//求栈顶
void Push(SqStack &, SElemType);//压栈
void Pop(SqStack &, SElemType);//弹栈并返回值
void StackTraverse(SqStack);//遍历栈


Status InitStack(SqStack &s)
{
	s.base = new SElemType[STACK_SIZE];
	if (!s.base) 
	{
		//exit(0);
		return ERROR;
	}
	else
	{
		s.top = s.base;
		s.stacksize = STACK_SIZE;
		return OK;
	}
}
Status DestroyStack(SqStack &s)
{
	delete[]s.base;
	if (s.base == NULL)
	{
		return OK;
	}
	else
		return ERROR;
}

Status ClearStack(SqStack&s)
{
	if (s.base == s.top)
	{
		cout << "栈为空，不需清空" << endl;
		return ERROR;
	}
	else
	{
		while (s.base != s.top)
		{
			s.top--;//栈顶下移
			s.stacksize++;//容量增加
		}
		return OK;
	}
}
void StackEmpty(SqStack s)
{
	if (s.base == s.top)
	{
		cout << "栈为空" << endl;
	}
	else
		cout << "栈非空" << endl;
}
int Stacklength(SqStack s)
{
	int i = 0;
	if (s.base == s.top)
	   ；
	else
	{
		while (s.base != s.top)
		{
			i++;
			s.top--;
		}	
	}
	return i;
}
SElemType Gettop(SqStack s)
{
	return *s.top;//返回栈顶元素
}
void Push(SqStack &s, SElemType x)
{
	if (s.top-s.base==s.stacksize)//栈满判断条件 
	{
	}
	else
	{
		*s.top = x;//压栈
		s.top++;
		//上面两步合成*s.top++=x;
	}
}
void Pop(SqStack &s, SElemType m)
{
	if (s.top == s.base)
	{
		cout << "栈空" << endl;
	}
	else
	{
		m = *s.top;
		s.top--;
		//上面两步合成m = *--s.top;
	}
}
void StackTraverse(SqStack s)
{
	if (s.base == s.top)
	{
		cout << "栈为空" << endl;
	}
	else
	{
		while (s.top != s.base)
		{
			cout << *s.top << "  ";
			s.top--;//向下移动
		}
	}
}

void main()
{
	SqStack mystack;
	cout<<InitStack(mystack);
	Push(mystack, 100);
	StackEmpty(mystack);
	Stacklength(mystack);
	system("pause");
}
